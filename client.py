import time
from fountain import Fountain
from glass import Glass

m = """
	Fountain codes provide a way for a file to be transmitted along a lossy network connection. The name "fountain code" arises because fountain codes behave analogously to a fountain. The file being transmitted is analogous to a glass of water from the fountain. To fill the glass (or reconstruct the file), you need to catch enough droplets from the fountain such that your glass becomes full. It isn't important which droplets of water you catch in your glass; once you have enough, the glass is full and the file can be reconstructed. Fountain codes work in the same way, but with information instead of water. The file being transferred can be algorithmically encoded as an arbitrarily large number of chunks that can be sent over the network. The receiving client then needs to receive some number of these chunks (droplets) in order to reconstruct the original file. It doesn't matter which droplets are received or in what order they are received, and it doesn't matter which are lost over the network. This is the beauty of fountain codes. So long as a sufficient number of droplets are received, the original file can be reconstructed completely.
	We'll explore the motivation for fountain codes, how these codes are implemented, as well as why their properties can be useful for file transfer over the internet.
	One application that at a glance seems to merit use of fountain codes is torrent sites. For users looking to download large files over a possibly temperamental connection, the fountain code seems ideal. Even if the connection is lost for a substantial period of time, which may be unavoidable with peer-to-peer connections, the fountain code will continue to work without the need for sending confirmation bits indicating that packets have been received. The result is that I can start a connection with any user, and they can start spewing out droplets for a particular file; they are the fountain. If I stop catching their droplets, someone else with the file can apply the same algorithm to continue sending me the file without knowing how much of the file I've already received or which parts of the previous transmission were dropped. While this seems ideal for peer to peer file transfer, it has one fatal flaw that we need additional algorithms to resolve.
	The flaw I speak of is a security vulnerability. With applications like BitTorrent, a sha1 hash of the file being transferred is used to verify that the sender of the file can be trusted to send the file, instead of sending malicious software to run on your computer. We are able to verify that the data being transmitted can be trusted using by comparing the hash of the file to the hash we received from the sender. When using fountain codes, the droplets that are sent over the network cannot be verified, because they are generated dynamically during transmission, and there is an arbitrarily large number of these chunks. It is therefore infeasible to precompute the hash of all possible droplets at the start of the transmission. One solution for this is to send the hash of the entire file, but that cannot be checked until the transmission has completed, which is too late in the process to be practical. Ideally we could detect corrupt files during the transmission.
	It seems remarkable that any droplets can be caught and the file can still be reconstructed. We look now at one possible implementation of fountain codes.
	The encoding scheme for this implementation is simple. First, the file is broken into chunks. We will look later at how best to choose the size of the chunk for the encoding mechanism. Let us use 8 chunks of 1 MB in this example. For each droplet that will be transmitted, we will select 3 of these chunks, and XOR them together. The number of chunks to combine in this manner also affects the performance of the algorithm, and we will examine the tradeoffs here as well. Suppose for our first droplet we choose chunks 1, 3, and 7. These chunks are XOR'd together and the result is transmitted over the network along with enough information for the receiving client to figure out which chunks were included. There are two ways to supply this information. The first, and simplest, is to include the chunk numbers in the transmitted droplet. With larger numbers of chunks, this amount of information could be prohibitively large. The second method of transmitting the chunk numbers is for the sender and receiver to agree on a random number generator that will be used to generate the chunk numbers. The sender then merely includes the seed used to create the chunk numbers inside the droplet. When the droplet is caught, the receiving client then uses the same random number generator with the same seed to determine which chunks were included in the droplet.
	The decoding method is a little more complicated. As droplets are caught, the receiving client stores them all. They need sufficient information to determine the contents of each chunk of the original file uniquely. Suppose the receiving client has droplets with chunks (1, 3, and 7), (1, 3, 4), and (1, 4, 7). Then the XOR of these three chunks will produce precisely chunk 1 of the original file. The algorithm works by having the client simply wait until it has sufficient information to reconstruct all of the chunks. These are then concatenated together to produce the original file.
	I implemented the encoding and decoding algorithms here. I have set up a server as a fountain at ________ and a web client at ________. You can watch as the web client receives chunks for the fountain and is slowly able to reconstruct the original file, which I chose to be this essay. I include the source code here ________, also available on GitHub at __________.
With this algorithm implemented, I was able to examine its efficiency. Experimentally I've found that the client typically has to receive ________ droplets before being able to reconstruct the entire file of ____ chunks. This implementation is not the industry standard, but it is the easiest implementation of fountain codes to implement and to explain. By changing ___, fountain codes can be improved. This type of implementation still relies on the model of catching droplets, but is more suitable to real world applications.
	However, fountain codes have the downside of transmitting files only in their entirety. If insufficient droplets are received, there is no guarantee that any continuous part of the file will be readable. Other methods exist for applications where it would be better to receive the file in continuous segments. For such applications, such as watching YouTube videos, streaming data is more applicable. The water analogues never seem to end.
"""

f = Fountain(m)	
